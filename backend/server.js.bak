const express = require('express');
const cors = require('cors');
const mysql = require('mysql2');
const NodeCache = require('node-cache');
require('dotenv').config();

// Helper function to get cache TTL based on time filter
const getCacheTTL = (timeFilter) => {
  switch (timeFilter) {
    case '5m': return 30;  // 30 seconds for 5m data
    case '10m': return 60;  // 1 minute for 10m data
    case '30m': return 120; // 2 minutes for 30m data
    case '1h': return 300;  // 5 minutes for 1h data
    default: return 600;    // 10 minutes for longer ranges
  }
};

// Initialize cache with default 5 minutes TTL
const cache = new NodeCache({ stdTTL: 300 });

// Validate time filter
const isValidTimeFilter = (timeFilter) => {
  const validFilters = ['5m', '10m', '30m', '1h', '2h', '6h', '1d', '2d', '5d', '1w', '2w', '30d'];
  return validFilters.includes(timeFilter);
};

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Rate limiting middleware
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60 // limit each IP to 60 requests per windowMs
});

// Apply rate limiting to all routes
app.use(limiter);

// Database connection
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// Test database connection
pool.getConnection((err, connection) => {
  if (err) {
    console.error('Error connecting to the database:', err);
    return;
  }
  console.log('Successfully connected to database');
  connection.release();
});

// Routes
app.get('/api/nodes', async (req, res) => {
  try {
    const [rows] = await pool.promise().query('SELECT DISTINCT NodeName FROM node_status_table ORDER BY NodeName');
    // Transform the rows into the expected format
    const nodes = rows.map(row => ({
      id: row.NodeName,  // Use NodeName as the id
      name: row.NodeName // Use NodeName as the display name
    }));
    res.json(nodes);
  } catch (error) {
    console.error('Error fetching nodes:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      details: process.env.NODE_ENV === 'development' ? error.message : undefined 
    });
  }
});

app.get('/api/basestations/:nodeName', async (req, res) => {
  const { nodeName } = req.params;
  try {
    const [rows] = await pool.promise().query(
      'SELECT DISTINCT NodeBaseStationName FROM node_status_table WHERE NodeName = ?',
      [nodeName]
    );
    
    const baseStations = rows.map(row => ({
      id: row.NodeBaseStationName,
      name: row.NodeBaseStationName
    }));
    
    res.json(baseStations);
  } catch (error) {
    console.error('Error fetching base stations:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined 
    });
  }
});

// Telemetry data endpoint
app.get('/api/telemetry/:nodeName/:baseStation', async (req, res) => {
  const { nodeName, baseStation } = req.params;
  const { timeFilter = '1h', page = 1, pageSize = 100 } = req.query;
  
  if (!isValidTimeFilter(timeFilter)) {
    return res.status(400).json({ error: 'Invalid time filter' });
  }
  
  try {
    const startTime = Date.now();
    console.log(`Fetching telemetry data for node: ${nodeName}, base station: ${baseStation}`);
    console.log('Request parameters:', { timeFilter, page, pageSize });
    
    const data = await getTelemetryData(pool, nodeName, baseStation, timeFilter, parseInt(page), parseInt(pageSize));
    
    const responseTime = Date.now() - startTime;
    console.log(`Telemetry data fetched in ${responseTime}ms`);
    
    if (data.data && data.data.length > 0) {
      console.log(`Returned ${data.data.length} data points (${data.total} total)`);
    } else {
      console.warn('No data returned for the selected time range');
    }
    
    res.json(data);
  } catch (error) {
    console.error('Error fetching telemetry data:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Helper function to get telemetry data with pagination
{{ ... }}
const getTelemetryData = async (pool, nodeName, baseStation, timeFilter, page = 1, pageSize = 500) => {
  // Set time range based on filter
  let timeRangeMinutes;
  let samplingInterval;
  
  switch (timeFilter) {
    case '5m': 
      timeRangeMinutes = 5;
      samplingInterval = '10 SECOND';
      break;
    case '10m':
      timeRangeMinutes = 10;
      samplingInterval = '15 SECOND';
      break;
    case '30m':
      timeRangeMinutes = 30;
      samplingInterval = '30 SECOND';
      break;
    case '1h':
      timeRangeMinutes = 60;
      samplingInterval = '1 MINUTE';
      break;
    case '2h':
      timeRangeMinutes = 120;
      samplingInterval = '2 MINUTE';
      break;
    case '6h':
      timeRangeMinutes = 360;
      samplingInterval = '5 MINUTE';
      break;
    case '1d':
      timeRangeMinutes = 1440;
      samplingInterval = '15 MINUTE';
      break;
    case '2d':
      timeRangeMinutes = 2880;
      samplingInterval = '30 MINUTE';
      break;
    case '5d':
      timeRangeMinutes = 7200;
      samplingInterval = '1 HOUR';
      break;
    case '1w':
      timeRangeMinutes = 10080;
      samplingInterval = '2 HOUR';
      break;
    case '2w':
      timeRangeMinutes = 20160;
      samplingInterval = '4 HOUR';
      break;
    case '30d':
      timeRangeMinutes = 43200;
      samplingInterval = '6 HOUR';
      break;
    default:
      timeRangeMinutes = 60;
      samplingInterval = '1 MINUTE';
  }
  
  const offset = (page - 1) * pageSize;

  // Debug query to check time range
  const timeRangeQuery = `
    SELECT 
      MAX(time) as latest_time,
      MIN(time) as earliest_time
    FROM node_status_table
    WHERE NodeName = ? AND NodeBaseStationName = ?
  `;

  const [[timeRange]] = await pool.promise().query(timeRangeQuery, [nodeName, baseStation]);
  console.log('Available time range in database:', {
    earliest: timeRange.earliest_time,
    latest: timeRange.latest_time
  });

  const query = `
    WITH RECURSIVE time_slots AS (
      SELECT 
        DATE_SUB(NOW(), INTERVAL ? MINUTE) as slot_start,
        DATE_SUB(NOW(), INTERVAL (?-1) MINUTE) as slot_end,
        1 as minute_num
      UNION ALL
      SELECT 
        slot_start + INTERVAL 1 MINUTE as slot_start,
        slot_end + INTERVAL 1 MINUTE as slot_end,
        minute_num + 1 as minute_num
      FROM time_slots
      WHERE minute_num < ?
    ),
    sampled_data AS (
      SELECT 
        ts.slot_start as sample_time,
        COALESCE(AVG(ns.Analog1Value), 0) as forwardPower,
        COALESCE(AVG(ns.Analog2Value), 0) as reflectedPower,
        COALESCE(AVG(ns.Analog3Value), 0) as vswr,
        COALESCE(AVG(ns.Analog4Value), 0) as returnLoss,
        COALESCE(AVG(ns.Analog5Value), 0) as temperature,
        COALESCE(AVG(ns.Analog6Value), 0) as voltage,
        COALESCE(AVG(ns.Analog7Value), 0) as current,
        COALESCE(AVG(ns.Analog8Value), 0) as power
      FROM 
        time_slots ts
      LEFT JOIN 
        node_status_table ns
      ON 
        ns.time >= ts.slot_start 
        AND ns.time < ts.slot_end
        AND ns.NodeName = ?
        AND ns.NodeBaseStationName = ?
      GROUP BY 
        ts.slot_start
      ORDER BY 
        ts.slot_start DESC
      LIMIT ? OFFSET ?
    )
    SELECT 
      DATE_FORMAT(sample_time, '%Y-%m-%d %H:%i:00') as sample_time,
      forwardPower,
      reflectedPower,
      vswr,
      returnLoss,
      temperature,
      voltage,
      current,
      power
    FROM sampled_data
    ORDER BY sample_time DESC
  `;

  const countQuery = `
    SELECT COUNT(*) as total
    FROM (
      SELECT 1
      FROM node_status_table
      WHERE NodeName = ?
        AND NodeBaseStationName = ?
        AND time >= DATE_SUB(NOW(), INTERVAL ? MINUTE)
      GROUP BY FLOOR(UNIX_TIMESTAMP(time) / 60)
    ) as time_slots
  `;

  console.log('Executing queries with params:', {
    timeRangeMinutes,
    nodeName,
    baseStation,
    pageSize,
    offset
  });

  const [[{ total }], data] = await Promise.all([
    pool.promise().query(countQuery, [nodeName, baseStation, timeRangeMinutes]),
    pool.promise().query(query, [timeRangeMinutes, timeRangeMinutes, timeRangeMinutes, nodeName, baseStation, pageSize, offset])
  ]);
  
  // Debug time range of returned data
  if (data[0].length > 0) {
    const returnedData = data[0];
    console.log('Returned data time range:', {
      start: returnedData[returnedData.length - 1]?.sample_time || 'N/A',
      end: returnedData[0]?.sample_time || 'N/A',
      requestedMinutes: timeRangeMinutes,
      recordCount: total,
      dataPoints: returnedData.length
    });
    
    // Log first and last few data points for debugging
    console.log('First data point:', returnedData[0]);
    if (returnedData.length > 1) {
      console.log('Last data point:', returnedData[returnedData.length - 1]);
    }
  }

  return {
    data: data[0],
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize)
  };
};
    res.json(result);
  } catch (error) {
    console.error('Error fetching telemetry data:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
