import jsPDF from 'jspdf';
import React from 'react';
import * as ReactDOM from 'react-dom/client';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import html2canvas from 'html2canvas';
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';



const generateAnalysis = (metric, data) => {
  // Reuse the analysis logic from HTMLReport.js
  const currentValue = data[data.length - 1]?.[metric] || 0;
  const values = data.map(item => item[metric]).filter(val => val !== null && val !== undefined);
  const average = values.reduce((a, b) => a + b, 0) / values.length;
  const percentageChange = ((currentValue - average) / average) * 100;

  let status = 'normal';
  let recommendation = '';

  switch (metric) {
    case 'forwardPower':
      if (currentValue < 10) {
        status = 'warning';
        recommendation = 'Forward power is low. Check transmitter output.';
      }
      break;
    case 'reflectedPower':
      if (currentValue > 2) {
        status = 'warning';
        recommendation = 'High reflected power detected. Check antenna system.';
      }
      break;
    // Add other metrics analysis here
  }

  return {
    currentValue,
    average,
    percentageChange,
    status,
    recommendation
  };
};

const renderGraph = async (data, metric) => {
  const chartContainer = document.createElement('div');
  chartContainer.style.width = '600px';
  chartContainer.style.height = '300px';
  chartContainer.style.position = 'absolute';
  chartContainer.style.left = '-9999px';
  document.body.appendChild(chartContainer);

  const chart = (
    <LineChart width={600} height={300} data={data}>
      <CartesianGrid strokeDasharray="3 3" />
      <XAxis dataKey="sample_time" />
      <YAxis />
      <Tooltip />
      <Legend />
      <Line
        type="monotone"
        dataKey={metric.name}
        stroke={getGraphColor(metric.name)}
        dot={false}
      />
    </LineChart>
  );

  const root = ReactDOM.createRoot(chartContainer);
  root.render(chart);

  // Wait for chart to render
  await new Promise(resolve => setTimeout(resolve, 500));

  try {
    const canvas = await html2canvas(chartContainer, {
      logging: false,
      useCORS: true,
      scale: 2
    });
    
    const imgData = canvas.toDataURL('image/png', 1.0);
    root.unmount();
    document.body.removeChild(chartContainer);
    
    return imgData;
  } catch (error) {
    console.error('Error generating chart:', error);
    root.unmount();
    document.body.removeChild(chartContainer);
    throw error;
  }
};

const getGraphColor = (dataKey) => {
  switch (dataKey) {
    case 'forwardPower': return '#4CAF50';
    case 'reflectedPower': return '#F44336';
    case 'vswr': return '#2196F3';
    case 'returnLoss': return '#FF9800';
    case 'temperature': return '#E91E63';
    case 'voltage': return '#9C27B0';
    case 'current': return '#FF5722';
    case 'power': return '#607D8B';
    default: return '#757575';
  }
};

export const generatePDFReport = async (config) => {
  try {
    // 1. Fetch telemetry data
    const response = await axios.get(`${API_BASE_URL}/api/telemetry/${config.node}/${config.baseStation}`, {
      params: {
        timeFilter: config.timeRange
      }
    });
    const telemetryData = response.data.data;

    // 2. Process metrics
    const metrics = [
      { name: 'forwardPower', title: 'Forward Power', unit: 'W' },
      { name: 'reflectedPower', title: 'Reflected Power', unit: 'W' },
      { name: 'vswr', title: 'VSWR', unit: '' },
      { name: 'returnLoss', title: 'Return Loss', unit: 'dB' },
      { name: 'temperature', title: 'Temperature', unit: 'Â°C' },
      { name: 'voltage', title: 'Voltage', unit: 'V' },
      { name: 'current', title: 'Current', unit: 'A' },
      { name: 'power', title: 'Power', unit: 'W' }
    ];

    // 3. Create PDF document
    const pdf = new jsPDF('p', 'mm', 'a4');
    let yPosition = 20;
    let currentPage = 1;

    // Add header function
    const addHeader = () => {
      pdf.setFontSize(10);
      pdf.setTextColor(102, 102, 102);
      pdf.text(`Page ${currentPage}`, 180, 10);
      currentPage++;

      // Add footer
      pdf.setFontSize(8);
      pdf.text('Generated by BSI Telemetry Reporting System', 20, 287);
      pdf.text(new Date().toLocaleString(), 150, 287);
    };

    // Add first page header
    addHeader();

    // Add header with modern styling
    pdf.setFillColor(248, 249, 250);
    pdf.rect(20, 20, 170, 20, 'F');
    pdf.setFontSize(20);
    pdf.setTextColor(25, 118, 210);
    pdf.text('Telemetry Report', 25, 33);

    // Add report info
    yPosition = 50;
    pdf.setFontSize(10);
    pdf.setTextColor(102, 102, 102);
    pdf.text(`Node: ${config.node}`, 25, yPosition);
    pdf.text(`Base Station: ${config.baseStation}`, 25, yPosition + 7);
    pdf.text(`Time Range: ${config.timeRange}`, 25, yPosition + 14);
    pdf.text(`Generated: ${new Date().toLocaleString()}`, 25, yPosition + 21);
    yPosition += 35;

    // Process each metric
    for (const metric of metrics) {
      // Check if we need a new page
      if (yPosition > 250) {
        pdf.addPage();
        addHeader();
        yPosition = 20;
      }

      // Add metric header
      pdf.setFillColor(255, 255, 255);
      pdf.setDrawColor(224, 224, 224);
      pdf.roundedRect(20, yPosition, 170, 65, 3, 3, 'FD');

      pdf.setFontSize(14);
      pdf.setTextColor(44, 62, 80);
      pdf.text(metric.title, 25, yPosition + 10);

      // Add graph
      try {
        const graphDataUrl = await renderGraph(telemetryData, metric);
        if (graphDataUrl) {
          pdf.addImage(graphDataUrl, 'PNG', 25, yPosition + 15, 160, 40);
        }
      } catch (error) {
        console.error('Error adding graph to PDF:', error);
      }

      // Add analysis
      const analysis = generateAnalysis(metric.name, telemetryData);
      pdf.setFontSize(10);
      pdf.setTextColor(102, 102, 102);
      pdf.text(`Current: ${analysis.currentValue.toFixed(2)} ${metric.unit}`, 25, yPosition + 60);
      pdf.text(`Avg: ${analysis.average.toFixed(2)} ${metric.unit}`, 85, yPosition + 60);
      pdf.text(`Change: ${analysis.percentageChange.toFixed(2)}%`, 145, yPosition + 60);

      yPosition += 75;
    }

    // Save the PDF
    pdf.save(`telemetry-report-${config.node}-${config.baseStation}.pdf`);

  } catch (error) {
    console.error('Error generating PDF report:', error);
    throw error;
  }
};
